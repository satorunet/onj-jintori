<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>CPU Bot Test - Bodyguard</title>
    <script src="https://cdn.jsdelivr.net/npm/msgpack-lite@0.1.26/dist/msgpack.min.js"></script>
    <style>
        body {
            font-family: monospace;
            background: #1a1a2e;
            color: #0f0;
            padding: 20px;
        }

        .bot {
            display: inline-block;
            margin: 5px;
            padding: 10px;
            background: #16213e;
            border-radius: 5px;
            min-width: 150px;
        }

        .bot.connected {
            border: 2px solid #0f0;
        }

        .bot.disconnected {
            border: 2px solid #f00;
            opacity: 0.5;
        }

        .bot.expanding {
            border: 2px solid #0ff;
            background: #002233;
        }

        .bot.returning {
            border: 2px solid #f0f;
            background: #330022;
        }

        .bot.attacking {
            border: 2px solid #f00;
            background: #330000;
            color: #ffcccc;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        h1 {
            color: #e94560;
        }

        #stats {
            margin-top: 20px;
            padding: 10px;
            background: #0f3460;
            border-radius: 5px;
        }

        .mode {
            font-size: 0.8em;
            color: #aaa;
        }

        #controls {
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <h1>ü§ñ CPU Bot Test - Sato's Bodyguards</h1>
    <p>„Çµ„Éº„Éê„Éº: wss://new-node02.open2ch.net:2053</p>
    <p>Âãï‰Ωú: sato„Å´ËøΩÈöè„Åó„Å¶Èô£Âú∞Êã°Â§ß & ÊïµÁô∫Ë¶ãÊôÇ„ÅØÂç≥ÊôÇÊîªÊíÉ</p>

    <div id="controls">
        <label>Bot Count: <input type="number" id="botCountInput" value="20" min="1" max="50"></label>
        <button onclick="startBots()">Start Bots</button>
        <button onclick="stopBots()">Stop Bots</button>
    </div>

    <div id="bots"></div>
    <div id="stats">
        <div>Êé•Á∂öÊï∞: <span id="connected">0</span></div>
        <div>Âèó‰ø°„É°„ÉÉ„Çª„Éº„Ç∏Êï∞: <span id="msgCount">0</span></div>
        <div id="worldInfo">World: 3000x3000</div>
        <div id="leaderInfo">Leader: Êé¢Á¥¢‰∏≠...</div>
    </div>

    <script>
        const SERVER_URL = 'wss://new-node02.open2ch.net:2053';
        let BOT_COUNT = 20;
        const TEAM_NAME = 'EXP'; // Expansion Team
        const LEADER_KEYWORD = 'sato'; // Leader name keyword

        let bots = [];
        let totalMsgs = 0;
        let aiInterval = null;

        // World Info
        let WORLD_WIDTH = 3000;
        let WORLD_HEIGHT = 3000;
        let obstacles = [];
        let allPlayers = [];

        function startBots() {
            stopBots();
            const count = parseInt(document.getElementById('botCountInput').value) || 10;
            BOT_COUNT = count;
            document.getElementById('bots').innerHTML = '';

            for (let i = 0; i < BOT_COUNT; i++) {
                setTimeout(() => createBot(i), i * 100);
            }

            if (!aiInterval) aiInterval = setInterval(runAI, 100);
        }

        function stopBots() {
            bots.forEach(b => {
                if (b.socket) b.socket.close();
            });
            bots = [];
            if (aiInterval) clearInterval(aiInterval);
            aiInterval = null;
            updateStats();
        }

        function createBot(index) {
            const name = `Bot${index + 1}`;
            const botDiv = document.createElement('div');
            botDiv.className = 'bot disconnected';
            botDiv.id = `bot-${index}`;
            botDiv.innerHTML = `<div><strong>${name}</strong></div><div class="status">Êé•Á∂ö‰∏≠...</div><div class="mode">ÂæÖÊ©ü</div>`;
            document.getElementById('bots').appendChild(botDiv);

            const bot = {
                name: name,
                index: index,
                socket: null,
                connected: false,
                myId: null,
                team: TEAM_NAME,
                x: 0,
                y: 0,
                homeX: null,
                homeY: null,
                state: 'out',
                targetX: 0,
                targetY: 0,
                moveTimer: 0
            };

            try {
                bot.socket = new WebSocket(SERVER_URL);
                bot.socket.binaryType = 'arraybuffer';

                bot.socket.onopen = () => {
                    bot.connected = true;
                    // botDiv.className = 'bot connected'; 
                    botDiv.querySelector('.status').textContent = 'Êé•Á∂öÂÆå‰∫Ü';
                    updateStats();

                    bot.socket.send(JSON.stringify({
                        type: 'join',
                        name: name,
                        team: TEAM_NAME
                    }));
                };

                bot.socket.onmessage = (e) => {
                    totalMsgs++;
                    if (totalMsgs % 100 === 0) updateStats();

                    let data;
                    if (e.data instanceof ArrayBuffer) {
                        try {
                            data = msgpack.decode(new Uint8Array(e.data));
                        } catch (err) { return; }
                    } else {
                        data = JSON.parse(e.data);
                    }

                    if (data.type === 'init') {
                        bot.myId = data.id;
                    }
                    if (data.type === 'round_start') {
                        if (data.world) {
                            WORLD_WIDTH = data.world.width;
                            WORLD_HEIGHT = data.world.height;
                            document.getElementById('worldInfo').textContent = `World: ${WORLD_WIDTH}x${WORLD_HEIGHT}`;
                        }
                        if (data.obstacles) { obstacles = data.obstacles; }
                    }
                    if (data.type === 's' || data.type === 'state') {
                        const players = data.p || data.players || [];
                        allPlayers = players;
                        const me = players.find(p => (p.i || p.id) === bot.myId);
                        if (me) {
                            bot.x = me.x;
                            bot.y = me.y;
                        }
                    }
                    if (data.type === 'player_death' && data.id === bot.myId) {
                        bot.state = 'out';
                    }
                };

                bot.socket.onclose = () => {
                    bot.connected = false;
                    botDiv.className = 'bot disconnected';
                    updateStats();
                };

            } catch (err) { }

            bots.push(bot);
        }

        function updateStats() {
            const connected = bots.filter(b => b.connected).length;
            document.getElementById('connected').textContent = connected;
            document.getElementById('msgCount').textContent = totalMsgs;
        }

        function runAI() {
            // Find Leader (Sato)
            const leader = allPlayers.find(p => {
                const name = (p.n || p.name || '').toLowerCase();
                return name.includes(LEADER_KEYWORD);
            });

            if (leader) {
                document.getElementById('leaderInfo').textContent = `Leader: ${leader.n || leader.name} (${Math.round(leader.x)}, ${Math.round(leader.y)})`;
            } else {
                document.getElementById('leaderInfo').textContent = `Leader: Êú™Áô∫Ë¶ã (Ëá™ÂæãË°åÂãï‰∏≠)`;
            }

            bots.forEach((bot, idx) => {
                if (!bot.connected || !bot.socket || bot.socket.readyState !== WebSocket.OPEN) return;
                if (bot.x === 0 && bot.y === 0) return;

                const botDiv = document.getElementById(`bot-${bot.index}`);
                let dx = 0, dy = 0;
                let attacking = false;

                // 1. Enemy Check (ATTACK PRIORITY)
                let nearestDist = Infinity;
                let nearestEnemy = null;

                allPlayers.forEach(p => {
                    const pId = p.i || p.id;
                    const pTeam = p.t || p.team;
                    const pName = p.n || p.name || '';
                    if (pId === bot.myId) return;
                    if (pTeam === bot.team) return; // Same team bot safe
                    if (pName.toLowerCase().includes(LEADER_KEYWORD)) return; // Leader safe

                    const distSq = (p.x - bot.x) ** 2 + (p.y - bot.y) ** 2;
                    if (distSq < nearestDist) {
                        nearestDist = distSq;
                        nearestEnemy = p;
                    }
                });

                // Attack range: 400px (Aggressive)
                if (nearestEnemy && nearestDist < 400 * 400) {
                    attacking = true;
                    dx = nearestEnemy.x - bot.x;
                    dy = nearestEnemy.y - bot.y;

                    if (botDiv) {
                        botDiv.className = 'bot attacking';
                        botDiv.querySelector('.mode').textContent = 'ÊîªÊíÉ‰∏≠!';
                    }
                    bot.state = 'out'; // Reset expand state
                }

                // 2. Normal Logic (Follow Leader & Expand)
                if (!attacking) {
                    // Set Home Position
                    if (leader) {
                        // Â∞ë„Åó„É©„É≥„ÉÄ„É†„Å´„Åö„Çâ„Åó„Å¶„ÄÅ„É™„Éº„ÉÄ„Éº„ÅÆÂë®„Çä„Å´Áæ§„Åå„Çã„Çà„ÅÜ„Å´„Åô„Çã
                        // „Åü„Å†„ÅÆËøΩÂæì„Åß„ÅØ„Å™„ÅèHome„Å®„Åó„Å¶‰Ωø„ÅÜ„ÅÆ„Åß„ÄÅExpand„É≠„Ç∏„ÉÉ„ÇØ„Åå„Åù„Åì„Çí‰∏≠ÂøÉ„Å´Â±ïÈñã„Åï„Çå„Çã
                        // ÊØéÂõûÊõ¥Êñ∞„Åô„Çã„Å®Expand„Åå„ÅÜ„Åæ„Åè„ÅÑ„Åã„Å™„ÅÑ„ÅÆ„Åß„ÄÅ‰∏ÄÂÆöË∑ùÈõ¢Èõ¢„Çå„Åü„ÇâÊõ¥Êñ∞„ÄÅ„ÅÇ„Çã„ÅÑ„ÅØHomeÂºïÂäõ„Å®„Åó„Å¶‰Ωø„ÅÜ
                        bot.homeX = leader.x;
                        bot.homeY = leader.y;
                    } else {
                        if (bot.homeX === null) { bot.homeX = bot.x; bot.homeY = bot.y; }
                    }

                    if (bot.state === 'out') {
                        if (bot.moveTimer <= 0) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 100 + Math.random() * 200;
                            bot.targetX = bot.x + Math.cos(angle) * dist;
                            bot.targetY = bot.y + Math.sin(angle) * dist;
                            bot.moveTimer = 20 + Math.random() * 10;
                        }
                        dx = bot.targetX - bot.x;
                        dy = bot.targetY - bot.y;
                        bot.moveTimer--;
                        if (bot.moveTimer <= 0) {
                            bot.state = 'in';
                            if (botDiv) {
                                botDiv.className = 'bot returning';
                                botDiv.querySelector('.mode').textContent = 'Â∏∞ÈÇÑ‰∏≠';
                            }
                        } else {
                            if (botDiv) {
                                botDiv.className = 'bot expanding';
                                botDiv.querySelector('.mode').textContent = 'Êã°Âºµ‰∏≠';
                            }
                        }
                    } else {
                        if (bot.homeX !== null) {
                            dx = bot.homeX - bot.x;
                            dy = bot.homeY - bot.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            // Âà∞ÈÅîÂà§ÂÆö („É™„Éº„ÉÄ„ÉºËøΩÂæì„ÅÆÂ†¥Âêà„ÅØ„ÅÇ„Åæ„ÇäËøë„Å•„Åç„Åô„Åé„Å™„ÅÑ„Çà„ÅÜ„Å´Â∞ë„ÅóÊâãÂâç„ÅßOK)
                            const arriveDist = leader ? 150 : 20;

                            if (dist < arriveDist) {
                                bot.state = 'out';
                                bot.moveTimer = 0;
                                if (!leader) {
                                    bot.homeX = bot.x;
                                    bot.homeY = bot.y;
                                }
                            }
                        }
                    }
                }

                // 3. Avoid Walls 
                const margin = 120;
                if (bot.x < margin) dx += 150;
                if (bot.x > WORLD_WIDTH - margin) dx -= 150;
                if (bot.y < margin) dy += 150;
                if (bot.y > WORLD_HEIGHT - margin) dy -= 150;

                // 4. Avoid Obstacles (Only if not attacking - Attack priority overrides obstacles slightly)
                // But generally good to avoid getting stuck
                const avoidRad = 80;
                obstacles.forEach(obs => {
                    const closeX = Math.max(obs.x, Math.min(bot.x, obs.x + obs.width));
                    const closeY = Math.max(obs.y, Math.min(bot.y, obs.y + obs.height));

                    const distanceX = bot.x - closeX;
                    const distanceY = bot.y - closeY;
                    const distSq = distanceX * distanceX + distanceY * distanceY;

                    if (distSq < avoidRad * avoidRad) {
                        const strength = 300;
                        const dist = Math.sqrt(distSq) || 1;
                        dx += (distanceX / dist) * strength;
                        dy += (distanceY / dist) * strength;
                    }
                });

                // Normalize and Send
                const mag = Math.sqrt(dx * dx + dy * dy);
                if (mag > 0) {
                    const nx = dx / mag;
                    const ny = dy / mag;
                    bot.socket.send(JSON.stringify([nx, ny]));
                }
            });
        }
    </script>
</body>

</html>