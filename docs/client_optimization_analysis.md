# クライアント重い処理の分析とサーバー側移行提案

**作成日:** 2026-01-07  
**対象:** クライアント側の重い処理の特定と最適化  

---

## 🔍 発見された重い処理

### 1. ✅ **ミニマップの国旗表示（実装済み）**

**場所:** `client-game.js`  
**頻度:** 毎フレーム（60FPS）  
**計算量:** O(n³) where n = territories数  
**状態:** ✅ サーバー側に移行完了

---

### 2. 🚨 **スコア画面の国旗表示（未対応）**

**場所:** `client-ui.js` (718-787行)  
**頻度:** ラウンド終了時に1回  
**計算量:** O(n³) where n = territories数  
**問題:** ミニマップと同じクラスタリングアルゴリズム

#### 現在の処理

```javascript
// client-ui.js: drawResultMapFrame()
Object.entries(teamRectLists).forEach(([teamName, rectList]) => {
    // クラスタリング（同じアルゴリズム）
    rectList.forEach((rect, i) => {
        while (changed) {
            rectList.forEach((other, j) => {
                for (const cr of cluster.rects) {
                    // 距離計算
                }
            });
        }
    });
});
```

**影響:**
- ラウンド終了時に一瞬フリーズする可能性
- 587個のterritories × クラスタリング = 重い

**優先度:** 🔴 **高** - ミニマップと同じ問題

---

### 3. ⚠️ **領地描画の最適化余地**

**場所:** `client-game.js` (297-312行)  
**頻度:** 毎フレーム（60FPS）  
**計算量:** O(n) where n = territories数  

#### 現在の処理

```javascript
// 毎フレーム全領地を描画
territories.forEach(t => {
    // 色でグループ化
    // 個別に描画
});
```

**問題点:**
- 587個の領地を毎フレーム処理
- グループ化も毎フレーム実行

**最適化案:**
- サーバー側で色ごとにグループ化して送信
- クライアント側はグループごとに一括描画

**優先度:** 🟡 **中** - 現状でも動作しているが改善余地あり

---

### 4. ⚠️ **プレイヤー軌跡の補間計算**

**場所:** `client-game.js` (208-238行)  
**頻度:** 毎フレーム × プレイヤー数  
**計算量:** O(m × p) where m = trail長, p = players数  

#### 現在の処理

```javascript
players.forEach(p => {
    // pixelTrailの補間計算
    if (!p.pixelTrail) {
        // trail全体をループしてpixelTrail生成
        p.trail.forEach((pt, idx) => {
            // 距離計算と補間
        });
    }
});
```

**問題点:**
- 新しいプレイヤーが見えるたびに全軌跡を補間計算
- 長い軌跡（50-100ポイント）で重い

**最適化案:**
- サーバー側で補間済みの軌跡を送信
- または補間アルゴリズムの軽量化

**優先度:** 🟢 **低** - 影響は小さい

---

### 5. ✅ **チームスコア集計（問題なし）**

**場所:** `client-game.js` (249-266行)  
**頻度:** 毎フレーム  
**計算量:** O(p) where p = players数  

**評価:** 軽量、問題なし

---

## 📊 優先順位別の推奨アクション

### 🔴 最優先: スコア画面の国旗表示

**理由:**
- ミニマップと同じクラスタリングアルゴリズム
- ラウンド終了時のフリーズの原因

**実装方法:**
1. サーバー側で計算した国旗位置を `round_end` メッセージに含める
2. クライアント側でクラスタリングコードを削除
3. 受信データをそのまま描画

**削減効果:**
- クライアント側: 約70行のコード削減
- 計算量: O(n³) → O(1)（受信して描画のみ）
- ラウンド終了時のフリーズ解消

---

### 🟡 中優先: 領地データの送信最適化

**現在:**
```javascript
// 個別の領地を送信
territories: [
  {o: "player1", c: "#ff0000", x: 100, y: 100, w: 50, h: 50},
  {o: "player1", c: "#ff0000", x: 150, y: 100, w: 50, h: 50},
  // ...
]
```

**最適化後:**
```javascript
// 色ごとにグループ化して送信
territoryGroups: {
  "#ff0000": [
    {x: 100, y: 100, w: 50, h: 50},
    {x: 150, y: 100, w: 50, h: 50}
  ]
}
```

**削減効果:**
- データサイズ: 10-20%削減（`o`と`c`の重複排除）
- クライアント側のグループ化処理不要

**優先度:** 中（効果は小さいが実装も簡単）

---

### 🟢 低優先: その他の最適化

1. **軌跡補間の改善** - 影響小
2. **Canvas描画の最適化** - 現状で問題なし
3. **リーダーボードの最適化** - 軽量

---

## 💡 総合推奨アクション

### Phase 1: 即座に実装（高効果）

✅ **スコア画面の国旗表示をサーバー側に移行**
- 実装時間: 30分
- 削減効果: ラウンド終了時のフリーズ解消
- リスク: 低（ミニマップと同じパターン）

### Phase 2: 検討（中効果）

🟡 **領地データのグループ化送信**
- 実装時間: 1-2時間
- 削減効果: データサイズ10-20%、描画処理軽量化
- リスク: 中（プロトコル変更が必要）

### Phase 3: 様子見（低効果）

🟢 **その他の細かい最適化**
- 必要性が出たら実装

---

## 🎯 次のステップ

**推奨: スコア画面の国旗表示をサーバー側に移行**

実装しますか？

---

**End of Document**
