<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Load Test (50 Hunter Bots)</title>
    <script src="https://cdn.jsdelivr.net/npm/msgpack-lite@0.1.26/dist/msgpack.min.js"></script>
    <style>
        body {
            background: #111;
            color: #eee;
            font-family: monospace;
        }

        .stat {
            font-size: 24px;
            font-weight: bold;
            color: #ef4444;
        }

        #log {
            margin-top: 20px;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>

<body>
    <h1>負荷テスト (Hunter Mode: 50 Bots)</h1>
    <div>Target: wss://new-node02.open2ch.net:2053</div>
    <div>接続数: <span id="conn-count" class="stat">0</span> / 50</div>
    <div id="log"></div>

    <script>
        const CLIENTS = 50;
        const TARGET_URL = 'wss://new-node02.open2ch.net:2053';

        let connectedCount = 0;
        const bots = [];

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML = `<div>${new Date().toLocaleTimeString()} ${msg}</div>` + el.innerHTML;
        }

        // 簡易距離計算
        function getDistSq(p1, p2) {
            return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
        }

        function createBot(id) {
            try {
                const ws = new WebSocket(TARGET_URL);
                ws.binaryType = 'arraybuffer';

                // Bot state
                const me = { id: null, x: 0, y: 0, target: null };
                // World state (他のプレイヤー位置)
                let others = [];

                ws.onopen = () => {
                    connectedCount++;
                    document.getElementById('conn-count').innerText = connectedCount;

                    // Join
                    const joinMsg = { type: 'join', name: 'Bot' + id, team: 'BOT' };
                    ws.send(msgpack.encode(joinMsg));

                    // Loop
                    const interval = setInterval(() => {
                        if (ws.readyState !== WebSocket.OPEN) {
                            clearInterval(interval);
                            return;
                        }

                        // Logic: Find nearest player and chase
                        let dx = 0, dy = 0;
                        let drawing = false;

                        // 自分以外で一番近いプレイヤーを探す
                        let nearest = null;
                        let minDst = 999999999;

                        others.forEach(p => {
                            if (p.i === me.id || p.id === me.id) return; // ignore self
                            // 座標データの揺れに対応 (p.x または p[1] など)
                            const tx = p.x;
                            const ty = p.y;
                            if (tx === undefined || ty === undefined) return;

                            const d = (me.x - tx) ** 2 + (me.y - ty) ** 2;
                            if (d < minDst) {
                                minDst = d;
                                nearest = { x: tx, y: ty };
                            }
                        });

                        if (nearest) {
                            // Chase logic
                            dx = nearest.x - me.x;
                            dy = nearest.y - me.y;
                            // Drawing logic: Draw when close to target or randomly
                            if (minDst < 500 * 500 && Math.random() > 0.5) drawing = true;
                        } else {
                            // Random move if no target
                            const angle = Math.random() * Math.PI * 2;
                            dx = Math.cos(angle);
                            dy = Math.sin(angle);
                        }

                        // Normalize
                        const mag = Math.sqrt(dx * dx + dy * dy);
                        if (mag > 0) { dx /= mag; dy /= mag; }

                        const inputMsg = {
                            type: 'input',
                            dx: dx,
                            dy: dy,
                            drawing: drawing
                        };
                        ws.send(msgpack.encode(inputMsg));
                    }, 100 + Math.random() * 100); // 100-200ms interval (High frequency)

                    bots.push({ ws, interval });
                };

                ws.onmessage = (e) => {
                    // Update world state to allow chasing
                    let data;
                    if (e.data instanceof ArrayBuffer) {
                        try { data = msgpack.decode(new Uint8Array(e.data)); } catch (err) { }
                    }
                    if (!data) return;

                    if (data.type === 'init') {
                        me.id = data.id;
                    } else if (data.type === 's' || data.type === 'state') {
                        // Update self position and others list
                        const players = data.p || data.players || [];
                        others = players;

                        // Find self to update current pos
                        const myData = players.find(p => p.i === me.id || p.id === me.id);
                        if (myData) {
                            me.x = myData.x;
                            me.y = myData.y;
                        }
                    }
                };

                ws.onclose = () => {
                    if (ws.readyState === WebSocket.OPEN || connectedCount > 0) {
                        connectedCount = Math.max(0, connectedCount - 1);
                    }
                    document.getElementById('conn-count').innerText = connectedCount;
                };

            } catch (e) {
                // log('Error: ' + e);
            }
        }

        // Start Bots
        let spawned = 0;
        const spawnInterval = setInterval(() => {
            if (spawned >= CLIENTS) {
                clearInterval(spawnInterval);
                log('All Hunter Bots spawned.');
                return;
            }
            createBot(spawned++);
        }, 150); // Spawn every 150ms

    </script>
</body>

</html>